\hypertarget{einleitung}{%
\chapter{Einleitung}\label{einleitung}}

Tracing ist die spezielle Verwendung der Protokollierung zur
Aufzeichnung von Informationen über den Ausführungsablauf eines
Programms. Oft werden mit eigenständig hinzugefügte Print-Messages der
Code debuggt. Somit verfolgt man die Anweisungen mit einem eigenem
tracing-System. Linux bringt einige eigenständige Tools mit, mit denen
es möglich ist Vorgänge innerhalb von einem Embedded-System
nachvollziehen und analysieren zu können. Die Linux-Tracing
Funktionalität und die bestehenden Tools, welche im Linux-Kernel
integriert sind, helfen so dabei bei der Identifikation von Laufzeiten,
Nebenläufigkeiten und der Untersuchung von Latenzproblemen,

\hypertarget{relevanz}{%
\section{Relevanz}\label{relevanz}}

\begin{itemize}
\tightlist
\item
  multicore systeme unterscheid mikotrkontroller
\end{itemize}

\hypertarget{tracing}{%
\section{Tracing}\label{tracing}}

\hypertarget{ursprung}{%
\section{Ursprung}\label{ursprung}}

\hypertarget{grundlagen}{%
\chapter{Grundlagen}\label{grundlagen}}

\hypertarget{ringbuffer}{%
\section{Ringbuffer}\label{ringbuffer}}

\hypertarget{debug-filesystem}{%
\section{Debug-Filesystem}\label{debug-filesystem}}

\begin{itemize}
\tightlist
\item
  möglichkeiten
\end{itemize}

\begin{lstlisting}[language=bash]
#ENABLE DEBUG FS
$ sudo mount -t debugfs debugfs /sys/kernel/debug
\end{lstlisting}

\hypertarget{trace-events}{%
\section{Trace Events}\label{trace-events}}

Durch das Debug-Filesystem ist jetzt der Zugriff auf die Debug und
insbesondere auf die Tracing-Daten möglich. Im Debug-Filesystem ist nach
aktivierung der \passthrough{\lstinline!tracing!}-Ordner vorhanden. In
diesem werden die verfügbaren Events in Gruppen (Ordnern) dargestellt,
auf welche im späteren Verlauf reagiert werden können.

\begin{itemize}
\tightlist
\item
  was sind tracers
\end{itemize}

\begin{lstlisting}[language=bash]
# GET TRACERS
$ cat /sys/kernel/debug/tracing/available_tracers
hwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup function nop
\end{lstlisting}

In der \passthrough{\lstinline!ls!} Ausgabe des
\passthrough{\lstinline!events!}-Ordners des Debug-Filesystems ist zu
sehen, welche Events abgefangen werden können und mittels der
Linux-Tracing-Tools protokoliert werden können.

\begin{lstlisting}[language=bash]
# GET AVAILABLE EVENT LIST
$ cd /sys/kernel/debug/tracing/events
$ ls -lah | awk '{print $9}'
alarmtimer
clk
cpuhp
drm
exceptions
ext4
# =>  EXT4_READPAGE, EXT4_WRITEPAGE, EXT4_ERROR, EXT4_FREE_BLOCKS
filelock
filemap
fs_dax
ftrace
gpio
# => GPIO_DIRECTION, GPIO_VALUE
hda
i2c
irq
net
smbus
# => READ, WRITE, REPLY
sock
# => SOCKET_STATE_CHANGED, SOCK_EXCEED_BUFFER_LIMIT, SOCK_REC_QUEUE_FULL
spi
tcp
timer
# => TIMER_STOP, TIMER_INIT, TIMER_EXPIRED
\end{lstlisting}

Alle Events sind in Gruppen gebündelt. Alle Events, welche das
\passthrough{\lstinline!ext4!}-Filesystem betreffen, befinden sich im
\passthrough{\lstinline!ext4!}-Ordner. Die Auflistung zeigt einige der
für das \passthrough{\lstinline!ext4!} zur Verfügung stehenden Events.
Zudem befinden sich zwei zusätzliche Dateien
\passthrough{\lstinline!enable!}, \passthrough{\lstinline!filter!}in
diesem Ordner. Durch diese ist es später möglich anzugeben, ob dieses
Event aufgezeichnet werden soll.

\begin{lstlisting}[language=bash]
$ cd /sys/kernel/debug/tracing/events/ext4
$ ls -lah | awk '{print $9}'

# EVENTS FOR EXT4
ext4_write_end
ext4_writepage
ext4_readpage
ext4_error

# INTERFACE FOR EVENT SETUP
enable
filter
format
\end{lstlisting}

Die optionale \passthrough{\lstinline!format!}-Datei kann zusätzliche
Informationen bereitstellen über das, durch das Event bereitgestellt
Format der Ausgabe. Das folgende Beispiel zeigt das Ausgabeformat für
die Formatbeschreibung für das Scheduler-Wakeup
\passthrough{\lstinline!sched\_wakeup!}-Event. Somit kann nicht nur in
Erfahrung gebracht werden, wann und ob das Event ausgelößt hat, sondern
es können auch weitere Event-Spezifische Informationen durch das Event
gemeldet werden.

\begin{lstlisting}[language=bash]
$  cat /sys/kernel/debug/tracing/events/sched/sched_wakeup/format
ID: 318
format:
    field:unsigned short common_type;   offset:0;   size:2; signed:0;
    field:unsigned char common_flags;   offset:2;   size:1; signed:0;
    field:unsigned char common_preempt_count;   offset:3;   size:1; signed:0;
    field:int common_pid;   offset:4;   size:4; signed:1;

    field:char comm[16];    offset:8;   size:16;    signed:1;
    field:pid_t pid;    offset:24;  size:4; signed:1;
    field:int prio; offset:28;  size:4; signed:1;
    field:int success;  offset:32;  size:4; signed:1;
    field:int target_cpu;   offset:36;  size:4; signed:1;
\end{lstlisting}

\hypertarget{abfangen-von-events}{%
\section{Abfangen von Events}\label{abfangen-von-events}}

\begin{lstlisting}[language=bash]
 $ cd /sys/kernel/debug/tracing
 $ echo 1 > events/sched/enable
\end{lstlisting}

\hypertarget{kprobes}{%
\subsection{kprobes}\label{kprobes}}

Kprobes können dazu verwendet werden, Laufzeit und Performance-Daten des
Kernels zu sammeln. Der Vorteil and diesen ist, dass diese Daten ohne
Unterbrechnung der Ausführung auf CPU-Instruktions-Ebene aggregiert
werden können, anders wie bei dem Debuggen eines Programms mittels
Breakpoints. Ein weiterer Vorteil ist, dass das Registrieren der Kprobes
dynamisch zur Laufzeit und ohne Änderungen des Programmcodes geschieht.

\hypertarget{kretprobes}{%
\subsection{kretprobes}\label{kretprobes}}

\hypertarget{cpu-traps}{%
\subsection{CPU-Traps}\label{cpu-traps}}

\hypertarget{uprobes}{%
\subsection{uprobes}\label{uprobes}}

\begin{itemize}
\tightlist
\item
  für anwendungn
\item
  system libs
\end{itemize}

\hypertarget{nachteile-verscfuxe4lschung}{%
\section{Nachteile / verscfälschung}\label{nachteile-verscfuxe4lschung}}

\begin{itemize}
\tightlist
\item
  welche effekte können entstehen
\item
  tracing bracuth ressoucen
\item
  last minimieren auf traget minimieren
\item
  nur aufzeichnen und später analysieren z.B. auf einem anderen system
\item
  wie verhindern
\end{itemize}

\hypertarget{tools}{%
\chapter{Tools}\label{tools}}

Allgemein sind keine speziellen Programme notwending um die
Laufzeiteigenschaften eines Programms aufzuzeichnen. Der Linux-Kernel
bringt bereits alle nötigen Funktionalitäten mit. Jedoch gibt es Tools
die eine visuelle Darstellung der aufgezeichneten Events ermöglichen.

\hypertarget{trace-log-aufzeichnung}{%
\section{Trace-Log Aufzeichnung}\label{trace-log-aufzeichnung}}

Für die Log-Aufzeichnung wird ein Ringbuffer genutzt. Das Aufzeichnen in
den Ringpuffer ist Standardmäßig aktiviert.

\begin{lstlisting}[language=bash]
# Disable the Recording on the ringbuffer
$ echo 0 > tracing on
\end{lstlisting}

Mit dem folgenden Befehl kann der Inhalt des Ringuffers, auch während
einer Aufzeichung, ausgebeben werden:

\begin{lstlisting}[language=bash]
$ less trace
\end{lstlisting}

Das Lesen während einer Aufzeichnung mit trace hat keinerlei Einfluss
auf den Inhalt des Ringpuffers. Die Ausgabe des letzten Kommandos wird
dabei in einem menschenlesbaren Format dargestellt:

\begin{figure}
\centering
\includegraphics{images/trace-log-print.png}
\caption{Trace-Log \label{trace-log}}
\end{figure}

Die bisheirgen Aufzeichnungen der Ereignisse können mit einem einfachen
Befehl entfernt werden:

\begin{lstlisting}[language=bash]
$ echo > trace
\end{lstlisting}

Um einen Überlauf an Informationen zu verhinden kann die Aufzeichnung
auch konsumierend gelesen werden. Somit werden beim Lesen zeitgleich
diese aus dem Ringbuffer entfernt.

Eine weitere Kernpunkt ist, dass in Mehrkernsystemen für jeden einzelnen
Core ein separater Ringbuffer existiert. Damit die Analyse von
verschiedenen Events getrennt werden kann, kann mit jeder weiteren
Instanz pro Core ein weiterer Ringbuffer angelgt werden. Dies erfolgt im
Untervereziechnis \passthrough{\lstinline!instances/!}.

\begin{lstlisting}[language=bash]
$ cd instances
$ mkdir inst0
$ mkdir inst1

# Remove if the instances is not needed anymore
# rmdir inst0
\end{lstlisting}

\begin{figure}
\centering
\includegraphics{images/ringbuffer.png}
\caption{Ringbuffer \label{ringbuffer}}
\end{figure}

\hypertarget{trace-cmd}{%
\subsection{trace-cmd}\label{trace-cmd}}

Das Tool \passthrough{\lstinline!trace-cmd!} ist das bekannteste und am
meisten genutzte Hilfmittel zur Aufzeichnung. Dies ist ein
kommandozeilenwerkzeug, das auf den meisten gängingen Linux
Distrubitionen bereits vorinstalliert ist.

\begin{lstlisting}[language=bash]
# CHECK IF TRACING IS ENABLED
# RUN AS SUDO
$ mount | grep tracefs
## => none on /sys/kernel/tracing type tracefs (rw,relatime,seclabel)

# IF TRACING IS NOT ACTIVE, ENABLE IT FIRST

## ONLY SCHEDULER EVENTS
$ echo sched_wakeup >> /sys/kernel/debug/tracing/set_event
## ALL EVENTS
$ echo *:* > /sys/kernel/debug/tracing/set_event


# RECORD
$ trace-cmd record -e sched ./program_executable
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  output erklörung
\end{itemize}

Mit dem letzten Befehl werden die ganzen Events zu Scheduler
aufgezeichnet. Dabei werden während der Aufzeichnung kontinuierlich die
Ringbuffer in konsumierender Form ausgelesen und in die Datei
\passthrough{\lstinline!trace.dat!} geschrieben, falls mit dem
\passthrough{\lstinline!-o!} keine eigene Datei eingegeben wurde. Als
Informationen werden zu dem Inhalt des Ringbuffers auch zusätzlich
notwendige Informationen über das Target, für die Auswertung auf
beliebigen System gespeichert.

Die \passthrough{\lstinline!trace-cmd!} Konsolenanwendung dient nicht
nur zur Aufzeichnung der Trace-Events, sondern bietet auch die
Möglichkeit augezeichnetet Reports visuell darzustellen. Die Ausgabe
erfolgt mit dem Befehl
\passthrough{\lstinline!trace-cmd report [-i <Dateiname>]!} als Tabelle
in der Konsole und ist somit rein Textbasiert, siehe dazu die nächste
Abbildung.

\begin{figure}
\centering
\includegraphics{images/trace-cmd.png}
\caption{trace-cmd Report \label{trace-cmd-report}}
\end{figure}

Auf diese Aufzeichnung zusätzlich ein Filter angewendet werden, um die
Suche auf bestimten Erreignissen einzugrenzen.

Mit dem Tool ist es einfach die Teilschritte zu automatisieren.

\hypertarget{bpftrace}{%
\subsection{bpftrace}\label{bpftrace}}

Seit der Kernelversion \passthrough{\lstinline!>4.x!}, kann ein weiteres
Tool mit dem Namen \passthrough{\lstinline!bpftrace!} verwendet werden.
Dieses bietet jedoch zusätzlich eine eigene Skripsprache mit der nicht
nur Aggreation, sondern auch die Eventfilter und die Verarbeitung der
Ergebnisse automatisiert werden können.

\begin{lstlisting}[language=bash]
# Block I/O latency as a histogram EXAMPLE
$ wget https://raw.githubusercontent.com/iovisor/bpftrace/master/tools/biolatency.bt
$ bftrace ./biolatency.bt
# @usecs:
# [512, 1K)             10 |@                       |
# [ 1K, 2K)            426 |@@@@@@@@@@@@@@@@@@      |
# [2K, 4K)             230 |@@@@@@@@@@@@@@          |
# [4K, 8K)               9 |@                       |
# [8K, 16K)            128 |@@@@@@@@@@@@@@@         |
# [16K, 32K)            68 |@@@@@@@@                |
# ...
\end{lstlisting}

\hypertarget{kernelshark}{%
\subsection{Kernelshark}\label{kernelshark}}

Das zuvor erklärte \passthrough{\lstinline!tace-cmd!} ist wie oben
erwähnt nur ein textbasiertes Analysetool. Das kommende Kernelshark Tool
bietet dem Anwender die Möglichkeit die Traceaufzeichnungen grafisch zu
analysieren. Dabei sind die beiden Tools aufeinander abgestimmt und
werden gemeinsam entwickelt. Auch dieses Tool ist in den meisten Linux
Distrubutionen vorinstalliert.

Das vom trace-cmd erzeugte \passthrough{\lstinline!trace.dat-Format!}
wird im Kernelshark als Eingabe erwartet. Wenn im folgendem ersten
Befehl nichts eingegeben, dann wird nach der entsprechenden
\passthrough{\lstinline!trace.dat!} im Verzeichnis gesucht.

\begin{lstlisting}[language=bash]
$ kernelshark
$ kernelshark -i <Dateiname>
\end{lstlisting}

Im folgenden ist die grafische Darstellung zu sehen. Dabei besitzt jeder
Task ein eigenen Farbton. Für jede CPU wird eine eigene Zeile
dargestellt. Dieses Tool hat eine gewisse Ähnlichkeit mit der von uns
genutzten Logic 2 Software.

\begin{figure}
\centering
\includegraphics{images/kernelshark.png}
\caption{Kernelshark \label{kernelshark}}
\end{figure}

\hypertarget{interpretation-des-kernel-trace-ergebnisses}{%
\chapter{Interpretation des Kernel-Trace
Ergebnisses}\label{interpretation-des-kernel-trace-ergebnisses}}

\hypertarget{beispiel---tcp-paketanalyse-beispiel}{%
\chapter{Beispiel - TCP Paketanalyse
Beispiel}\label{beispiel---tcp-paketanalyse-beispiel}}

Dieses erste Beispiel

\hypertarget{beispiel---identifikation-von-laufzeitproblemen}{%
\chapter{Beispiel - Identifikation von
Laufzeitproblemen}\label{beispiel---identifikation-von-laufzeitproblemen}}

In diesem Abschnitt soll an einem einfache Beispiel gezeigt werden, wie
es mittels Tracing möglich ist, eine Laufzeitanalyse auf verschiedenen
Systemen für eine Anwendung durchzuführen.

\hypertarget{ausgangsszenario}{%
\section{Ausgangsszenario}\label{ausgangsszenario}}

Als Ausgangspunkt dieses Beispiels, soll das Laufzeitverhalten eines
Programms auf einem Linux-System analysiert werden. Die zugrunde
liegende Software wurde bisher nur auf einem Linux-Realtime Kernel
verwendet, jedoch erfordert die Implementation neuer Features eine
neuere Kernel-Version, welche noch nicht als RT-Version auf dem System
zur Verfügung steht. Somit soll ermittelt werden, ob die unmodifizierte
Software eins zu eins auf dem neuen System lauffähig ist und die
Laufzeitandorderungen erfüllt.

Das System besteht hier aus einem
\passthrough{\lstinline!RaspberryPi 4B!} mit einer angeschlossenen LED
am GPIO-Port \passthrough{\lstinline!25!} und zu testende Programm lässt
diese dabei in 100ms Abständen Blinken.

\begin{lstlisting}[language={C++}]
#include <iostream>
#include <wiringPi.h>
#include <csignal>
using namespace std;

void signal_callback_handler(int signum) {

}

int main(int argc, char *argv[])
{
    //REGISTER SIGNAL HANDLER
    signal(SIGINT, signal_callback_handler);

    wiringPiSetup();            // Setup the library
    pinMode(0, OUTPUT);     // Configure GPIO0 as an output
    pinMode(1, INPUT);      // Configure GPIO1 as an input
    bool state = false;

    while(1)
    {
        state = !state;
        digitalWrite(0, state);
        delay(500);
    }
    return 0;
}
\end{lstlisting}

Für den Test wurde als RT Kernel die Version
\passthrough{\lstinline!4.19.59-rt23-v7l+!} verwendet, welche nicht alle
Funktionaltitäten des aktuellen \passthrough{\lstinline!5.10!} Kernel
besitzt. In diesem fiktiven Beispiel, wird die
\passthrough{\lstinline!systemd-networking >V.248!} Funktionalität für
das Batman-Prokoll benötigt, welche den Grund für die Umstellung
darstellt und nicht trivial in den \passthrough{\lstinline!4.x!} Kernel
integriert werden kann.

Die Messungen wurden zuerst auf dem aktuellen
\passthrough{\lstinline!5.10 LTS!} Kernel aufgezeichnet und im Anschluss
wurde der RT-Kernel auf einem anderen System per Cross-Compilation aus
dem \passthrough{\lstinline!rpi-4.19.y-rt!} Branch des
\passthrough{\lstinline!raspberrypi/linux!} Repository gebaut. Dieser
Schritt war notwendig, da es kein fertiges RT-Kernel Image zur Verfügung
stand. Die erzeugten Dateien wurden dann auf die Boot-Partition der SD
Karte geschrieben und in der \passthrough{\lstinline!/boot/config.txt!}
Datei wurde der neue Kernel hinterlegt
\passthrough{\lstinline!kernel=kernel7\_rt.img!}.

\hypertarget{aufzeichnung-trace-log}{%
\section{Aufzeichnung Trace-Log}\label{aufzeichnung-trace-log}}

Zur Aufzeichnung des Trace-Logs wurde
\passthrough{\lstinline!trace-cmd!} verwendet. Auf dem Zielsystem wurde
dabei nur die Aufzeichnung vorgenommen und die Analyse der Logs erfolgte
auf einem seperaten System.

\hypertarget{aktivierung-der-events}{%
\subsection{Aktivierung der Events}\label{aktivierung-der-events}}

\begin{lstlisting}[language=bash]
$ echo 1 > /sys/kernel/debug/tracing/tracing_on
$ cat /sys/kernel/debug/tracing/trace
$echo > /sys/kernel/debug/tracing/trace
\end{lstlisting}

\begin{lstlisting}[language=bash]
trace-cmd record -e sched ./blink
\end{lstlisting}

\hypertarget{visualisierung-und-beurteilung-des-trace-logs-mittels-kernelshark}{%
\section{Visualisierung und Beurteilung des Trace-Logs mittels
kernelshark}\label{visualisierung-und-beurteilung-des-trace-logs-mittels-kernelshark}}